---
title: C++ 11 右值引用与移动语义
date: 2019-05-07 13:35:58
tags:
  - c++
  - move semantic
draft: true
---

<!--more-->

## 左值、右值与将亡值

在旧的 C++0x 标准中，左值与右值的概念是相对简单的 —— 左值就是可以在赋值符号左侧的值，右值就是在赋值符号右侧的值 。例如 `int x = 3;` 中 `x` 即为左值，`3` 即为右值 。但是这种定义并不完善（就比如左值也可以出现在赋值符号右侧），同时也为了优化运行效率，C++11 引入了新的定义 。

### 表达式分类

```
         expression
        /         \
    glvalue       rvalue
   /      \      /      \
lvalue     xvalue      prvalue
```

C++11 中一切表达式都可已被分类为左值（left value）、纯右值（pure right value）与将亡值（expiring value）；其中左值或将亡值又合称为泛左值（general left value），将亡值或右值又合称为右值（right value） 。我们所要谈论的重点是左值与纯右值，因为将亡值~~我也不会~~很少用到就不做深入讨论了 。

### 左值

在现代 C++ 定义中，**左值更应该被称作可以取地址的值**，一切可以取到地址的都是左值 —— 这就解决了左值存在于赋值符号右侧的问题 。考虑以下例子：

```c++
#include <iostream>
using namespace std;

int lv1 = 2;
int& lv2 = lv1;
int* lv3 = &lv1;
int& lv4() { return lv1; }

int main() {
  lv4() = lv1 + lv2 + *lv3;
  cout << lv1 << endl;
  return 0;
}
```

这里 `lv1`（对象）、`lv2`（引用）、`lv3`（指针）、`lv4`（函数）都是左值，因为它们都是可取地址的 。其中 `lv4` 尤其值得注意，因为它是一个返回左值引用的函数，从而使得它也成为左值 —— 这在没有引用的 C 语言中是无法实现的 。稍后还会谈到右值引用 。

### 纯右值

纯右值不能被取地址，它通常包括：

-   非字符串的字面量，例如 `2` `true` `nullptr`
-   返回非引用类型的函数或运算符重载表达式
-   大部分运算符操作的结果，例如 `2 + 3` `a < b`
-   生成的临时匿名变量，例如 `std::string()`

随着纯右值一起引入的还有右值引用 。考虑以下例子：

```c++
#include <iostream>

int main() {
  int &&v = 5;
  v = 6;
  std::cout << v << std::endl;
  return 0;
}
```

这里 v 就是一个右值引用 。如果你写作 `int &v = 5;`，编译器就会报错，因为你无法将纯右值转换为左值引用 —— 但你可以通过 `typename&&` 来声明一个右值引用并延长其生命周期 。

对整数类型使用右值引用看起来没太大意义，但在处理大型对象时我们就能看到它的作用 。

### 将亡值

## 移动语义

